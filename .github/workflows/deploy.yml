name: Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment (prod or staging)'
        required: true
        default: 'prod'
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'
  push:
    branches: [ main ]

env:
  PROD_DOMAIN: lucidledger.co
  STAGING_DOMAIN: staging.lucidledger.co

jobs:
  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Select target host/user
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.environment }}" = "staging" ]; then
          echo "TARGET_HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
          echo "TARGET_USER=${{ secrets.STAGING_USER }}" >> $GITHUB_ENV
          echo "TARGET_KEY<<EOF" >> $GITHUB_ENV
          echo "${{ secrets.STAGING_SSH_KEY }}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
        else
          echo "TARGET_HOST=${{ secrets.EC2_HOST }}" >> $GITHUB_ENV
          echo "TARGET_USER=${{ secrets.EC2_USER }}" >> $GITHUB_ENV
          echo "TARGET_KEY<<EOF" >> $GITHUB_ENV
          echo "${{ secrets.SSH_PRIVATE_KEY }}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
        fi

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ env.TARGET_KEY }}

    - name: Add EC2 to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H "$TARGET_HOST" >> ~/.ssh/known_hosts

    - name: Deploy to EC2
      run: |
        # Create deployment script
        # Note: GitHub Actions expressions are resolved before
        # the script is sent to EC2 via SSH, so secrets are never stored on disk.
        cat > deploy.sh << 'DEPLOY_EOF'
        #!/bin/bash
        set -e

        echo "Starting deployment..."

        # Check system resources
        echo "System resources:"
        free -h
        df -h /

        # Set domain based on input
        if [ "${{ github.event.inputs.environment }}" = "staging" ]; then
          DOMAIN="${{ env.STAGING_DOMAIN }}"
          BRANCH="${{ github.event.inputs.branch }}"
          [ -z "$BRANCH" ] && BRANCH=develop
          REPO_DIR="lucidledger-staging"
        else
          DOMAIN="${{ env.PROD_DOMAIN }}"
          BRANCH="${{ github.event.inputs.branch }}"
          [ -z "$BRANCH" ] && BRANCH=main
          REPO_DIR="lucidledger"
        fi

        # Navigate to project directory (try ubuntu user first, then ec2-user)
        cd "/home/ubuntu/$REPO_DIR" 2>/dev/null || cd "/home/ec2-user/$REPO_DIR" || {
          echo "Error: Could not find repository directory"
          exit 1
        }

        echo "Working directory: $(pwd)"

        # Pull latest changes
        echo "Pulling latest changes..."
        git pull origin "$BRANCH"

        # ============================================
        # Generate .env files from GitHub Secrets/Variables
        # ============================================
        echo "Generating environment files..."

        cat > client/.env << CLIENT_ENV_EOF
        # Auto-generated by GitHub Actions deploy workflow
        # Do not edit manually - update GitHub Secrets/Variables instead

        # Privy Configuration
        VITE_PRIVY_APP_ID=${{ vars.VITE_PRIVY_APP_ID }}

        # API Configuration
        VITE_API_BASE_URL=https://${DOMAIN}/api

        # Demo Mode
        VITE_DEMO_MODE=${{ vars.VITE_DEMO_MODE }}

        # Base Sepolia Blockchain Configuration
        VITE_BASE_SEPOLIA_CHAIN_ID=${{ vars.VITE_BASE_SEPOLIA_CHAIN_ID }}
        VITE_BASE_SEPOLIA_RPC=${{ vars.VITE_BASE_SEPOLIA_RPC }}
        VITE_BASESCAN_URL=${{ vars.VITE_BASESCAN_URL }}

        # Contract Addresses
        VITE_USDC_ADDRESS=${{ vars.VITE_USDC_ADDRESS }}
        VITE_FACTORY_ADDRESS=${{ vars.VITE_FACTORY_ADDRESS }}

        # Admin Configuration
        VITE_ADMIN_EMAILS=${{ vars.VITE_ADMIN_EMAILS }}
        CLIENT_ENV_EOF

        cat > server/.env << SERVER_ENV_EOF
        # Auto-generated by GitHub Actions deploy workflow
        # Do not edit manually - update GitHub Secrets/Variables instead

        # Database Configuration
        DB_HOST=${{ secrets.DB_HOST }}
        DB_PORT=${{ secrets.DB_PORT }}
        DB_NAME=${{ secrets.DB_NAME }}
        DB_USER=${{ secrets.DB_USER }}
        DB_PASSWORD=${{ secrets.DB_PASSWORD }}

        # Server Configuration
        PORT=5001
        NODE_ENV=production
        DEMO_MODE=${{ vars.DEMO_MODE }}

        # CORS Configuration
        CORS_ORIGIN=https://${DOMAIN}

        # Privy JWT Verification
        PRIVY_APP_ID=${{ vars.VITE_PRIVY_APP_ID }}
        PRIVY_APP_SECRET=${{ secrets.PRIVY_APP_SECRET }}
        PRIVY_JWKS_URL=${{ vars.PRIVY_JWKS_URL }}
        PRIVY_ISSUER=${{ vars.PRIVY_ISSUER }}

        # Admin Configuration
        ADMIN_EMAILS=${{ vars.ADMIN_EMAILS }}
        SERVER_ENV_EOF

        # Remove leading whitespace from heredoc indentation
        sed -i 's/^        //' client/.env server/.env

        echo "Environment files generated."

        # Stop existing services
        echo "Stopping existing services..."
        docker compose -f docker-compose.nginx.yml down || true

        # Clean up Docker to free memory
        echo "Cleaning up Docker..."
        docker system prune -af --volumes || true

        # Install/ensure docker buildx is available for BuildKit cache mounts
        echo "Setting up Docker Buildx..."
        if ! docker buildx version &>/dev/null; then
          echo "Installing docker buildx..."
          mkdir -p ~/.docker/cli-plugins
          ARCH=$(uname -m)
          [ "$ARCH" = "x86_64" ] && ARCH="amd64"
          [ "$ARCH" = "aarch64" ] && ARCH="arm64"
          BUILDX_VERSION=$(curl -s https://api.github.com/repos/docker/buildx/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' | sed 's/v//')
          curl -L "https://github.com/docker/buildx/releases/download/v${BUILDX_VERSION}/buildx-v${BUILDX_VERSION}.linux-${ARCH}" -o ~/.docker/cli-plugins/docker-buildx
          chmod +x ~/.docker/cli-plugins/docker-buildx
          docker buildx install || true
        fi
        docker buildx use default || docker buildx create --use --name default --driver docker || true

        # Rebuild and start services
        echo "Rebuilding and starting services..."
        # Enable BuildKit for faster builds with cache mounts
        export DOCKER_BUILDKIT=1
        docker compose -f docker-compose.nginx.yml up -d --build

        # Wait for services to be ready (longer wait for build process)
        echo "Waiting for services to be ready..."
        sleep 90

        # Check if services are running
        echo "Checking Docker containers..."
        docker ps

        # Check service status
        echo "Checking service status..."
        docker compose -f docker-compose.nginx.yml ps

        # Test deployment with retries
        echo "Testing deployment..."
        MAX_RETRIES=10
        RETRY_COUNT=0
        DEPLOYMENT_SUCCESS=false

        # Check SSL certificate status
        echo "Checking SSL certificates..."
        if [ -f "ssl/live/$DOMAIN/fullchain.pem" ]; then
          echo "SSL certificate found"
          openssl x509 -in ssl/live/$DOMAIN/fullchain.pem -noout -subject -dates 2>/dev/null || echo "Could not read certificate details"
        else
          echo "SSL certificate not found at ssl/live/$DOMAIN/fullchain.pem"
        fi

        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."

          # Test HTTP redirect first (should return 301)
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 http://$DOMAIN 2>/dev/null || echo "000")
          echo "  HTTP status: $HTTP_STATUS"

          # Test HTTPS connection
          HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 https://$DOMAIN 2>/dev/null || echo "000")
          if [ "$HTTPS_STATUS" = "000" ]; then
            # Try with -k to see if it's a certificate issue
            HTTPS_STATUS_INSECURE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k https://$DOMAIN 2>/dev/null || echo "000")
            if [ "$HTTPS_STATUS_INSECURE" != "000" ]; then
              echo "  HTTPS status: $HTTPS_STATUS (connection works with -k, likely SSL cert issue)"
            else
              echo "  HTTPS status: $HTTPS_STATUS (connection failed)"
            fi
          else
            echo "  HTTPS status: $HTTPS_STATUS"
          fi

          # Test API health endpoint (this uses HTTPS and is more reliable)
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k https://$DOMAIN/api/health 2>/dev/null || echo "000")
          echo "  API health status: $API_STATUS"

          # Also test via localhost (in case domain doesn't resolve from inside EC2)
          LOCAL_HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k https://localhost/ 2>/dev/null || echo "000")
          LOCAL_API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k https://localhost/api/health 2>/dev/null || echo "000")

          # Check if HTTPS is working (200, 301, or 302 are acceptable)
          # OR if API health endpoint works (which means HTTPS is working)
          if [ "$HTTPS_STATUS" = "200" ] || [ "$HTTPS_STATUS" = "301" ] || [ "$HTTPS_STATUS" = "302" ] || \
             [ "$API_STATUS" = "200" ] || [ "$LOCAL_HTTPS_STATUS" = "200" ] || [ "$LOCAL_API_STATUS" = "200" ]; then
            echo "Deployment successful! App accessible at https://$DOMAIN"
            if [ "$API_STATUS" = "200" ]; then
              echo "   (Verified via API health endpoint)"
            elif [ "$LOCAL_API_STATUS" = "200" ]; then
              echo "   (Verified via localhost API health endpoint)"
            fi
            DEPLOYMENT_SUCCESS=true
            break
          else
            echo "HTTPS not ready yet (HTTPS: $HTTPS_STATUS, API: $API_STATUS, Local: $LOCAL_HTTPS_STATUS), waiting 15 seconds..."
            sleep 15
            RETRY_COUNT=$((RETRY_COUNT + 1))
          fi
        done

        if [ "$DEPLOYMENT_SUCCESS" = "false" ]; then
          echo "Deployment test failed after $MAX_RETRIES attempts"
          echo "Checking service status..."
          docker compose -f docker-compose.nginx.yml ps
          echo "Checking nginx configuration..."
          docker exec nginx-proxy nginx -t 2>&1 || echo "Nginx config test failed"
          echo "Checking SSL certificate mount..."
          docker exec nginx-proxy ls -la /etc/letsencrypt/live/$DOMAIN/ 2>&1 || echo "SSL directory not found"
          echo "Checking service logs..."
          docker compose -f docker-compose.nginx.yml logs --tail=100 nginx
          echo "Testing connectivity from container..."
          docker exec nginx-proxy curl -s -o /dev/null -w "nginx->frontend: %{http_code}\n" http://frontend:80 || echo "Cannot reach frontend from nginx"
          docker exec nginx-proxy curl -s -o /dev/null -w "nginx->backend: %{http_code}\n" http://backend:5001/api/health || echo "Cannot reach backend from nginx"
          echo "Testing HTTPS from inside nginx container..."
          docker exec nginx-proxy curl -s -o /dev/null -w "Local HTTPS: %{http_code}\n" https://localhost/ 2>&1 || echo "HTTPS test from container failed"
          exit 1
        fi

        echo "Deployment completed successfully!"
        DEPLOY_EOF

        chmod +x deploy.sh

        # Execute deployment script on EC2
        ssh -o StrictHostKeyChecking=no "$TARGET_USER"@"$TARGET_HOST" 'bash -s' < deploy.sh

    - name: Deployment Status
      run: |
        echo "Deployment completed!"
        if [ "${{ github.event.inputs.environment }}" = "staging" ]; then
          echo "Staging at: https://${{ env.STAGING_DOMAIN }}"
        else
          echo "Production at: https://${{ env.PROD_DOMAIN }}"
        fi
        echo "Check the deployment status above for any errors"
