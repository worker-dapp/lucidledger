name: Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment (prod or staging)'
        required: true
        default: 'prod'
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'
  push:
    branches: [ main ]

env:
  PROD_DOMAIN: lucidledger.co
  STAGING_DOMAIN: staging.lucidledger.co

jobs:
  # test:
  #   name: Test Application
  #   runs-on: ubuntu-latest
  #   steps:
  #   - name: Checkout code
  #     uses: actions/checkout@v4

  #   - name: Setup Node.js (client)
  #     uses: actions/setup-node@v4
  #     with:
  #       node-version: '20'
  #       cache: 'npm'
  #       cache-dependency-path: client/package-lock.json

  #   - name: Install frontend dependencies
  #     working-directory: ./client
  #     run: |
  #       npm config set cache .npm-cache
  #       npm install

  #   - name: Build frontend
  #     working-directory: ./client
  #     env:
  #       VITE_API_BASE_URL: https://lucidledger.co/api
  #       VITE_DYNAMIC_ENV_ID: ${{ secrets.VITE_DYNAMIC_ENV_ID }}
  #     run: npm run build

  #   - name: Setup Node.js (server)
  #     uses: actions/setup-node@v4
  #     with:
  #       node-version: '18'
  #       cache: 'npm'
  #       cache-dependency-path: server/package-lock.json

  #   - name: Install backend dependencies
  #     working-directory: ./server
  #     run: |
  #       npm config set cache .npm-cache
  #       npm install
      
  #   - name: Run frontend tests
  #     working-directory: ./client
  #     run: npm run lint || echo "ESLint issues found, but continuing deployment"
      
  #   - name: Run backend tests
  #     working-directory: ./server
  #     run: npm run lint || echo "No lint script found, skipping"

  deploy:
    name: Deploy to EC2
    # needs: test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Select target host/user
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.environment }}" = "staging" ]; then
          echo "TARGET_HOST=${{ secrets.STAGING_HOST }}" >> $GITHUB_ENV
          echo "TARGET_USER=${{ secrets.STAGING_USER }}" >> $GITHUB_ENV
          echo "TARGET_KEY<<EOF" >> $GITHUB_ENV
          echo "${{ secrets.STAGING_SSH_KEY }}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
        else
          echo "TARGET_HOST=${{ secrets.EC2_HOST }}" >> $GITHUB_ENV
          echo "TARGET_USER=${{ secrets.EC2_USER }}" >> $GITHUB_ENV
          echo "TARGET_KEY<<EOF" >> $GITHUB_ENV
          echo "${{ secrets.SSH_PRIVATE_KEY }}" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
        fi

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ env.TARGET_KEY }}
        
    - name: Add EC2 to known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H "$TARGET_HOST" >> ~/.ssh/known_hosts
        
    - name: Deploy to EC2
      run: |
        # Create deployment script
        cat > deploy.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "ðŸš€ Starting deployment..."
        
        # Check system resources
        echo "ðŸ’¾ System resources:"
        free -h
        df -h /
        
        # Set domain based on input
        if [ "${{ github.event.inputs.environment }}" = "staging" ]; then
          DOMAIN="${{ env.STAGING_DOMAIN }}"
          BRANCH="${{ github.event.inputs.branch }}"
          [ -z "$BRANCH" ] && BRANCH=develop
          REPO_DIR="lucidledger-staging"
        else
          DOMAIN="${{ env.PROD_DOMAIN }}"
          BRANCH="${{ github.event.inputs.branch }}"
          [ -z "$BRANCH" ] && BRANCH=main
          REPO_DIR="lucidledger"
        fi
        
        # Navigate to project directory (try ubuntu user first, then ec2-user)
        cd "/home/ubuntu/$REPO_DIR" 2>/dev/null || cd "/home/ec2-user/$REPO_DIR" || {
          echo "âŒ Error: Could not find repository directory"
          exit 1
        }
        
        echo "ðŸ“ Working directory: $(pwd)"
        
        # Pull latest changes
        echo "ðŸ“¥ Pulling latest changes..."
        git pull origin "$BRANCH"
        
        # Stop existing services
        echo "ðŸ›‘ Stopping existing services..."
        docker-compose -f docker-compose.nginx.yml down || true
        
        # Clean up Docker to free memory
        echo "ðŸ§¹ Cleaning up Docker..."
        docker system prune -af --volumes || true
        
        # Install/ensure docker buildx is available for BuildKit cache mounts
        echo "ðŸ”§ Setting up Docker Buildx..."
        if ! docker buildx version &>/dev/null; then
          echo "Installing docker buildx..."
          mkdir -p ~/.docker/cli-plugins
          ARCH=$(uname -m)
          [ "$ARCH" = "x86_64" ] && ARCH="amd64"
          [ "$ARCH" = "aarch64" ] && ARCH="arm64"
          BUILDX_VERSION=$(curl -s https://api.github.com/repos/docker/buildx/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' | sed 's/v//')
          curl -L "https://github.com/docker/buildx/releases/download/v${BUILDX_VERSION}/buildx-v${BUILDX_VERSION}.linux-${ARCH}" -o ~/.docker/cli-plugins/docker-buildx
          chmod +x ~/.docker/cli-plugins/docker-buildx
          docker buildx install || true
        fi
        # Use default builder with docker driver (works with docker-compose v1)
        docker buildx use default || docker buildx create --use --name default --driver docker || true
        
        # Rebuild and start services with environment variables
        echo "ðŸ”¨ Rebuilding and starting services..."
        export VITE_API_BASE_URL="https://$DOMAIN/api"
        export VITE_DYNAMIC_ENV_ID="bb03ee6d-6f22-4d73-b630-439914bf6b18"
        export VITE_DEMO_MODE="true"
        # Enable BuildKit for faster builds with cache mounts
        export DOCKER_BUILDKIT=1
        export COMPOSE_DOCKER_CLI_BUILD=1
        docker-compose -f docker-compose.nginx.yml up -d --build
        
        # Wait for services to be ready (longer wait for build process)
        echo "â³ Waiting for services to be ready..."
        sleep 90
        
        # Check if services are running
        echo "ðŸ” Checking Docker containers..."
        docker ps
        
        # Check service status
        echo "ðŸ“Š Checking service status..."
        docker-compose -f docker-compose.nginx.yml ps
        
        # Test deployment with retries
        echo "ðŸ§ª Testing deployment..."
        MAX_RETRIES=10
        RETRY_COUNT=0
        DEPLOYMENT_SUCCESS=false
        
        # Check SSL certificate status
        echo "ðŸ” Checking SSL certificates..."
        if [ -f "ssl/live/$DOMAIN/fullchain.pem" ]; then
          echo "âœ… SSL certificate found"
          openssl x509 -in ssl/live/$DOMAIN/fullchain.pem -noout -subject -dates 2>/dev/null || echo "âš ï¸  Could not read certificate details"
        else
          echo "âš ï¸  SSL certificate not found at ssl/live/$DOMAIN/fullchain.pem"
        fi
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          echo "Attempt $((RETRY_COUNT + 1)) of $MAX_RETRIES..."
          
          # Test HTTP redirect first (should return 301)
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 http://$DOMAIN 2>/dev/null || echo "000")
          echo "  HTTP status: $HTTP_STATUS"
          
          # Test HTTPS connection
          HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 https://$DOMAIN 2>/dev/null || echo "000")
          if [ "$HTTPS_STATUS" = "000" ]; then
            # Try with -k to see if it's a certificate issue
            HTTPS_STATUS_INSECURE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k https://$DOMAIN 2>/dev/null || echo "000")
            if [ "$HTTPS_STATUS_INSECURE" != "000" ]; then
              echo "  HTTPS status: $HTTPS_STATUS (connection works with -k, likely SSL cert issue)"
            else
              echo "  HTTPS status: $HTTPS_STATUS (connection failed)"
            fi
          else
            echo "  HTTPS status: $HTTPS_STATUS"
          fi
          
          # Test API health endpoint (this uses HTTPS and is more reliable)
          API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k https://$DOMAIN/api/health 2>/dev/null || echo "000")
          echo "  API health status: $API_STATUS"
          
          # Also test via localhost (in case domain doesn't resolve from inside EC2)
          LOCAL_HTTPS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k https://localhost/ 2>/dev/null || echo "000")
          LOCAL_API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 -k https://localhost/api/health 2>/dev/null || echo "000")
          
          # Check if HTTPS is working (200, 301, or 302 are acceptable)
          # OR if API health endpoint works (which means HTTPS is working)
          if [ "$HTTPS_STATUS" = "200" ] || [ "$HTTPS_STATUS" = "301" ] || [ "$HTTPS_STATUS" = "302" ] || \
             [ "$API_STATUS" = "200" ] || [ "$LOCAL_HTTPS_STATUS" = "200" ] || [ "$LOCAL_API_STATUS" = "200" ]; then
            echo "âœ… Deployment successful! App accessible at https://$DOMAIN"
            if [ "$API_STATUS" = "200" ]; then
              echo "   (Verified via API health endpoint)"
            elif [ "$LOCAL_API_STATUS" = "200" ]; then
              echo "   (Verified via localhost API health endpoint)"
            fi
            DEPLOYMENT_SUCCESS=true
            break
          else
            echo "â³ HTTPS not ready yet (HTTPS: $HTTPS_STATUS, API: $API_STATUS, Local: $LOCAL_HTTPS_STATUS), waiting 15 seconds..."
            sleep 15
            RETRY_COUNT=$((RETRY_COUNT + 1))
          fi
        done
        
        if [ "$DEPLOYMENT_SUCCESS" = "false" ]; then
          echo "âŒ Deployment test failed after $MAX_RETRIES attempts"
          echo "ðŸ“Š Checking service status..."
          docker-compose -f docker-compose.nginx.yml ps
          echo "ðŸ“Š Checking nginx configuration..."
          docker exec nginx-proxy nginx -t 2>&1 || echo "Nginx config test failed"
          echo "ðŸ“Š Checking SSL certificate mount..."
          docker exec nginx-proxy ls -la /etc/letsencrypt/live/$DOMAIN/ 2>&1 || echo "SSL directory not found"
          echo "ðŸ“Š Checking service logs..."
          docker-compose -f docker-compose.nginx.yml logs --tail=100 nginx
          echo "ðŸ” Testing connectivity from container..."
          docker exec nginx-proxy curl -s -o /dev/null -w "nginx->frontend: %{http_code}\n" http://frontend:80 || echo "Cannot reach frontend from nginx"
          docker exec nginx-proxy curl -s -o /dev/null -w "nginx->backend: %{http_code}\n" http://backend:5001/api/health || echo "Cannot reach backend from nginx"
          echo "ðŸ” Testing HTTPS from inside nginx container..."
          docker exec nginx-proxy curl -s -o /dev/null -w "Local HTTPS: %{http_code}\n" https://localhost/ 2>&1 || echo "HTTPS test from container failed"
          exit 1
        fi
        
        echo "ðŸŽ‰ Deployment completed successfully!"
        EOF
        
        chmod +x deploy.sh
        
        # Execute deployment script on EC2
        ssh -o StrictHostKeyChecking=no "$TARGET_USER"@"$TARGET_HOST" 'bash -s' < deploy.sh
        
    - name: Deployment Status
      run: |
        echo "ðŸŽ¯ Deployment completed!"
        if [ "${{ github.event.inputs.environment }}" = "staging" ]; then
          echo "ðŸŒ Staging at: https://${{ env.STAGING_DOMAIN }}"
        else
          echo "ðŸŒ Production at: https://${{ env.PROD_DOMAIN }}"
        fi
        echo "ðŸ“± Check the deployment status above for any errors"